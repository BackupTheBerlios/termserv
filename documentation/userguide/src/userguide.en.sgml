<?xml version="1.0" encoding="is8859-1">
<!doctype book PUBLIC "-//OASIS//DTD DocBook V3.1//EN">

 
<book lang="en">
 
<title>GNU/Linux Terminalserver for schools
 
<bookinfo>
<bookbiblio>
<authorgroup>
<author>
<surname>Baum</surname>
<firstname>Georg</firstname>
<affiliation>
<address>
<email>gbaum@users.sourceforge.net</email>
</address>
</affiliation>
</author> 
<author>
<surname>Bingel</surname>
<firstname>Peter</firstname>
<affiliation>
<address>
<email>pb@fsub.schule.de</email>
</address>
</affiliation>
</author> 
<author>
<surname>Selig</surname>
<firstname>Christian</firstname>
<affiliation>
<address>
<email>christian.selig@bnv-bamberg.de</email>
</address>
</affiliation>
</author>
</authorgroup>
</bookbiblio>
</bookinfo>

<toc>
 
<chapter>
<title>Please help us!</title>

<para>
Dear reader, please consider helping us to translate the documentation
which is currently in German.
</para>
</chapter>

<chapter>
<title>Introduction</title>

<para>
It is a well-known situation: schools networks becomer bigger and
more complex, the collegues' requirements towards new media grow,
publishing companies, hardware producers and software creators
postulate a golden era.
</para>

<para> 
Pitily, reality doesn't look that good and 
Leider sieht die Wirklichkeit vor Ort nicht immer so rosig aus und 
vielerorts realisieren auch die Schulträger, dass die Kosten für 
Anschaffung und Wartung der Geräte, der Bedarf an Administration von 
Hard- und Software ständig wächst. Schulen mit 40, 50, 80 oder gar 
100 und mehr Rechnern sind keine Exoten mehr. Netze solcher Größenordnung  
erfordern leistungsfähige Server, kaskadierte Netze und  -- vor allem -- 
kompetente, rund um die Uhr verfügbare Systemadminstratoren,  die sich ihre
Arbeit in der Industrie teuer bezahlen lassen.
</para>

<para> 
Ständig steigender Wartungsaufwand und steigende Kosten lassen an der 
Schule nach anderen Lösungen als den bisher eingesetzten suchen. Es 
erweist sich mehr und mehr als Unding, die Anwendungssoftware auf 
jedem einzelnen Rechner zu installieren und zu warten. Zwar gibt es 
auch hierfür Lösungen, die aber vor allem durch eins glänzen: sie 
sind teuer. Schon deswegen teuer, weil für jeden Arbeitsplatz ein eigener 
kompletter Rechner gestellt und nach wenigen Jahren ersetzt werden muss.
</para>

<para>
A terminal server provides a solution for this dilemma. It is no
invention of the 21st century, but relies on a well-known and
[bewährten] approach.
</para>

<sect1>
<title>Idea and Principle</title>

<para>
The idea of a terminal server is simple: why provide software
and computing power on the workstation, which, e.g. while
using a word processor does essentially nothing?
Why not use to power of a single computer by letting multiple
users work with it?
</para>

<para> 
Of course, because multiple users can't sit in front of on screen
and one keyboard at the same time, the computer distributes
its power to a number of <quote>dumb</quote> terminals through a network.
These terminals are nothing more than a screen, a keyboard, a
mouse and a computing device that does not have to rely on
local storage and big memory.
</para>

<para> 
Generally, there are two types of terminals:

<itemizedlist>
<listitem>
<para>X-Terminal:
They are e.g. old computers with small hard disks that have a small operating
system installed and fetch all applications from the server.
</para>
</listitem>
<listitem>
<para>
Diskless Client:
These computers do not have local storage, all needed applications, including
the operating system, are fetched from the network.
</para>
</listitem>
</itemizedlist>

<para>
A terminal server solution consists of a well-equiped server, where all
applications are installed and configured and of basically administration-free
terminals that are connected with the server. These terminals are adminstration-free
because they have no software installed and no hard disks that can be damaged.
</para>
</sect1>

<sect1>
<title>Advantages</title>

<para> 
The terminal server fully exploits the advantages of a network. Used consequently, it
reduces the administration effort of the systems administrator enormously. But there's
even more to it:
 
<itemizedlist>
<listitem>
<para>Old computers can be reused as terminals.</para>
</listitem>
<listitem>
<para>Only one computer -- the server -- needs to be administered.</para>
</listitem>
<listitem>
<para>Software needs to be installed only one time, is administered centrally and
is available to all connected terminals.</para>
</listitem>
<listitem>
<para>It minimized the amount of time and money spent.</para>
</listitem>
</itemizedlist>  

</para>
</chapter>

<chapter>
<title>Terminal server networking basics</title>

<para>
A terminal server follows a very simple principle.
You should have a better understanding of the underlying schemata,
so that you have a better overview of your network and have
fewer problems when it comes to troubleshooting.
</para>

<sect1>
<title>Protocols</title>
 
<para>
Protocols are of fundamental importance within a network. They define
e.g. the network's address structure or the form of data exchange between
computers within a network.
</para>
 
<para>
These protocols are multi-tiered which means that one protocol may rely
on a more basic protocol. Protocol layering (from
the <quote>deep</quote> to the <quote>high</quote> level) looks like this:
<orderedlist>
<listitem>
<para><xref linkend="mac-addresses">
fixme: MAC addresses
</para>
</listitem>
<listitem>
<para>IP addresses</para>
</listitem>
<listitem>
<para>DNS, <xref linkend="dhcp-protocol">
fixme: DHCP
, TFTP, NFS, X11</para>
</listitem>
</orderedlist>
These protocols are also the protocols used in a terminal server network
and are described below.
</para>

<sect2 id="mac-addresses">
<title>MAC addresses</title>
 
<para>
MAC addresses are network addresses on the low level. Every network interface
card has a fixed MAC address (sometimes called <quote>hardware ethernet address</quote>).
It is determined by the card vendor. If two network interface cards in the
same network possessed the same MAC address, the network might be seriously
messed. But the card vendors have contracts concerning the distribution of
MAC addresses.
</para>
 
<sect3>
<title>Example</title>
 
<para>
A MAC address consists of six two-digit hexadecimal numbers which are
usually separated with colons, e.g. <emphasis>00:0D:84:F6:3A:10</emphasis>. 
</para>

<sect2>
<title>IP addresses</title>

<para> 
IP addresses define a network's logical structure. They are user-configurable.
</para>
 
<sect3>
<title>Example</title>

<para>
An IP address consists of four two-digit hexadecimal numbers, which are usually
written as decimal numbers for the sake of understandability. They are
separated with points. In a network, the server might have the IP address
<emphasis>192.168.1.1</emphasis>, The proxy server <emphasis>192.168.1.2</emphasis> and terminals
<emphasis>192.168.1.10</emphasis>, <emphasis>192.168.1.11</emphasis>, etc.
</para>
 
<sect2>
<title>Host names and domains (DNS)</title>

<para>
IP addresses are quite useful for structuring; however an IP-based network 
can contain up to 4 billion IP addresses! To avoid that everyone using
that network has to create his personal <quote>phone book</quote> for IP addresses
and instead enable the use of human-readable names, the domain naming
service (<quote>DNS</quote>) was developed. DNS servers in a network host a list
of IP addresses and their corresponding host names, which then can be
queried by hosts within the network.
</para>

<para>
The concept is domain-oriented, there is a hierarchy: 
<emphasis>arktur.cg-bamberg.de</emphasis> is a German (<emphasis>de</emphasis>) computer of the Clavius 
High School Bamberg (<emphasis>cg-bamberg</emphasis>) with the name <emphasis>arktur</emphasis>. The last
part is called top level Domain (short <quote>TLD</quote>), the second-last part is the
domain. Before that, there are either computers or further domains. 
</para> 

<sect2 id="dhcp-protocol">
<title>DHCP</title>

<para>
DHCP, the <quote>Dynamic Host Configuration Protocol</quote> is a protocol intended to make some
parts of network administration more convenient for the administrator. Usually, IP
addresses are assigned manually on each computer. That fact complicates administration
of bigger networks. DHCP solves this problem.
</para>

<para>
One computer has a DHCP service installed. The other computers are entered in the network with their Ethernet hardware address and the IP address determined by the administrator. Now if a computer in the network asks an inquiry after its IP address, the DHCP server answers with the appropriate value.
Auf einem Rechner wird die DHCP-Serversoftware installiert. Dort werden die einzelnen
Rechner im Netzwerk mit ihrer Ethernet-Hardware-Adresse und der vom Administrator festgelegten
IP-Adresse eingetragen. Stellt nun ein Rechner im Netzwerk eine Anfrage nach seiner
IP-Adresse, antwortet der DHCP-Server mit dem entsprechenden Wert.
</para>

<para>
Ein DHCP-Server ist in der Lage, einiges mehr an Werten an einen Rechner zurückzuliefern
als eine IP-Adresse. Jedoch ist der Großteil davon für Administration in der Praxis
recht unwichtig.
</para>
 
<sect2>
<title>TFTP - der simple Dateitransfer</title>

<para>
TFTP, das <quote>Trivial File Transfer Protocol</quote> ist ebenso ein Serverdienst. Er ist mit FTP 
vergleichbar, jedoch wesentlich simpler. So fordert der Server keine Identifikation mit
Benutzername und Passwort.
</para>

<para>
Im Terminalserver-Betrieb ist TFTP das Protokoll, das das Terminal benutzt, um seinen
Betriebssystem-Startcode (im Falle von Linux der <quote>Kernel</quote>) herunterzuladen.
</para>
 
<sect2>
<title>NFS - Dateien über das Netzwerk</title>

<para> 
Das Network File System - NFS - erlaubt das Verwalten von Dateien auf
mehreren Computern innerhalb eines Netzwerkes so, als ob sie auf der lokalen
Festplatte gespeichert wären. Dadurch ist es für den Benutzer nicht nötig zu wissen, wo die
Dateien physikalisch gespeichert sind, um auf sie zuzugreifen.
</para>

<para> 
Über NFS hat er von jedem Rechner im Netz gleichermaßen Zugriff auf sein Dateien. Dabei werden die
Dateien vom Server exportiert und vom Terminal importiert:
<emphasis>Jedes Terminal kann nur importieren, was der Server ausdrücklich exportiert!</emphasis>
 
<sect2>
<title>X11 - Fenster in der Ferne</title>

<para>
<mediaobject id="x-flow-diag">
<imageobject><imagedata fileref="userguide-networkbasics-protocols-x-flow.eps" format="eps"></imageobject>
<imageobject><imagedata fileref="userguide-networkbasics-protocols-x-flow.png" format="png"></imageobject>
<textobject><phrase>Funktionsweise des X11-Protokolls</phrase></textobject>
<caption><para>Funktionsweise des X11-Protokolls</para></caption>
</mediaobject>
</para>

<para>
X11 ist ein System, welches unter GNU/Linux- und Unix-Systemen die Grafikausgabe regelt.
Das Besondere an ihm ist seine Netzwerkfähigkeit. So kann ein Programm auf einem bestimmten Rechner
laufen, die Anzeige und Bedienung des Programms findet aber auf einem anderen Rechner statt! Im
GNU/Linux- bzw. Unix-Mehrbenutzerbetrieb können also beliebig viele Rechner
Programme auf einem einzigen Server starten und bei sich anzeigen lassen.
<xref linkend="x-flow-diag">
fixme: Eine Zeichnung
 gibt einen schematischen Überblick.
</para>

<para>
X11 hat ebenso ein ungewöhnliches, aber logisches Namensschema. Der Teil von X11, der
Grafikbefehle entgegennimmt und Tastatur- und Mauseingaben an ein Programm zurücksendet,
heißt X-Server. Ein Programm ist ein X-Client beziehungsweise benutzt die X-Client-Bibliotheken;
es sendet Grafikbefehle an einen X-Server und empfängt die aufgefangenen Tastatur- und
Mauseingaben von ihm.
</para>

<para>
Im Terminalserver-Betrieb laufen wie beschrieben die Programme -- und damit die X-Clients --
aller Benutzer auf dem Server, hingegen laufen auf den Terminals die X-Server!
</para>
</sect1>

<sect1>
<title>Vorgänge beim Starten eines Terminals</title>

<para> 
<itemizedlist>
<listitem>
<para> Das Terminal bootet. Nun wird ein Code auf dem Boot-ROM der Netzwerkkarte ausgeführt,
der alternativ auch von Diskette oder als DOS-Programm ausgeführt werden kann.
<listitem>
<para>Der Code des Boot-ROMs versucht über das sogenannte BOOTP- oder DHCP-Protokoll einen Server
im Netzwerk zu finden, der dem Terminal anhand seiner Hardware-Ethernet-Adresse
eine IP-Adresse zuweisen und weiteren Code zur Ausführung bereitstellen kann.
<listitem>
<para>Der Server, i.d.R. der gleiche Rechner wie der Terminalserver, stellt dem suchenden
Terminal seine IP-Adresse, die IP-Adresse eines Boot-Servers sowie den Namen eines vom Boot-Server
zu ladenden Startcodes zur Verfügung.
<listitem>
<para>Das Terminal lädt den Startcode mit dem TFTP-Protokoll, einem vereinfachten FTP-Protokoll.
Dieser Startcode ist ein entsprechend modifizierter Linux-Kernel.
<listitem>
<para>Der Linux-Kernel wird auf den Terminal geladen und ausgeführt. Nachdem er gestartet
ist, holt er sich sein gesamtes Dateisystem vom Terminalserver mit Hilfe des
NFS-Protokolls.
<listitem>
<para>Innerhalb dieses Dateisystems liegen Startscripts. Sie werden ausgeführt und
starten die graphische Oberfläche.
<listitem>
<para>Die graphische Oberfläche X11 sucht einen XDMCP-Server, das ist ein Rechner,
der in der Lage ist, die Graphikbefehle der laufenden Programme auf die Terminals
zu übertragen.
<listitem>
<para>Wenn ein solcher Server gefunden ist, verbindet sich der Terminal mit ihm. Ab
diesem Punkt arbeitet der Benutzer auf dem Server.
</itemizedlist>
</para>
</chapter>

<chapter>
<title>Installation und Konfiguration des Terminalservers</title>

<para>
Der Terminalserver wird auf eine beliebige schon bestehende Installation eines 
GNU/Linux-Systems aufgespielt.
</para>

<sect1>
<title>Überlegungen vor der Installation</title>

<sect2>
<title>Sicherheit</title>

<para>
Seit geraumer Zeit haben Sicherheitslücken auf allen Betriebssystemen
immer wieder Aufsehen erregt. Rechner wurden mit teilweise geringstem
Aufwand kompromitiert. Da Ihr Terminalserver, auf dem möglicherweise
auch persönliche Dokumente und wichtige Arbeitsdaten liegen, geschützt
sein soll, darf der Terminalserver nicht gleichzeitig als Zugangsrechner
(Gateway, Router) zum Internet verwendet werden! Benutzen Sie dazu einen
zweiten Rechner, auf den Sie beispielsweise den Arktur-Kommunikationsserver
installiert haben. Dieser sorgt für die notwendige Sicherheit und Abschirmung
vor Angreifern aus dem Internet.
</para>
</sect1>
  
<sect1>
<title>Software-Pakete</title>

<para>
Die Pakete des Terminalservers liegen im rpm- und deb-Format vor. Das
deb-Format wird von der Debian-Distribution (und allen abgeleiteten wie
Progeny oder Corel), das rpm-Format von praktisch allen anderen gängigen
Distributionen wie SuSE, RedHat und Mandrake benutzt.
</para>

<sect2>
<title>Immer benötigte Pakete</title>

<para>
Diejenigen Pakete, die auf jeden Fall benötigt werden, werden auf
Debian-Systemen durch Installieren des Pakets <literal>task-termserv</literal> automatisch
mitinstalliert.
</para>

<para>
Auf rpm-basierten Systemen kann der Abhängigkeitsliste von <literal>task-termserv</literal>
entnommen werden, welche Pakete benötigt werden.
</para>

<para>
Als Abhängigkeit und Voraussetzung für das <literal>task-termserv</literal>-Paket
findet sich auch die Administrationssoftware Webmin 
(<ulink url="http://www.webmin.com/">http://www.webmin.com/</ulink>)
und das dazugehörige LTSP-Konfigurationsmodul. Sie können damit Ihren zukünftigen
Terminalserver über eine Web-Oberfläche konfigurieren (dazu später). Wollen Sie
diese beiden Pakete nicht, müssen Sie die anderen Pakete einzeln installieren!
</para>

<sect2>
<title>Von der Terminalhardware abhängige Pakete</title>

<para>
Abhängig von den zur Verfügung stehenden Terminals sind die zu installierenden
Kernel- und X-Server-Pakete.

<table>
<title>X-Server-Pakete</title>
<tgroup cols="3">
<thead>
<row><entry>X-Server</entry>	<entry>rpm-Paket</entry>			<entry>deb-Paket</entry></row>
</thead>
<tbody>
<row><entry>3dlabs</entry>	<entry>lts_x3dlabs-2.0-1.i386.rpm</entry>	<entry>lts-xserver-3dlabs_2.0-1_all.deb</entry></row>
<row><entry>8514</entry>	<entry>lts_x8514-2.0-1.i386.rpm</entry>		<entry>lts-xserver-8514_2.0-1_all.deb</entry></row>
<row><entry>agx</entry>		<entry>lts_xagx-2.0-1.i386.rpm</entry>		<entry>lts-xserver-agx_2.0-1_all.deb</entry></row>
<row><entry>fbdev</entry>	<entry>lts_xfbdev-2.0-1.i386.rpm</entry>	<entry>lts-xserver-fbdev_2.0-1_all.deb</entry></row>
<row><entry>i128</entry>	<entry>lts_xi128-2.0-1.i386.rpm</entry>		<entry>lts-xserver-i128_2.0-1_all.deb</entry></row>
<row><entry>mach32</entry>	<entry>lts_xmach32-2.0-1.i386.rpm</entry>	<entry>lts-xserver-mach32_2.0-1_all.deb</entry></row>
<row><entry>mach64</entry>	<entry>lts_xmach64-2.0-1.i386.rpm</entry>	<entry>lts-xserver-mach64_2.0-1_all.deb</entry></row>
<row><entry>mach8</entry>	<entry>lts_xmach8-2.0-1.i386.rpm</entry>	<entry>lts-xserver-mach8_2.0-1_all.deb</entry></row>
<row><entry>mono</entry>	<entry>lts_xmono-2.0-1.i386.rpm</entry>		<entry>lts-xserver-mono_2.0-1_all.deb</entry></row>
<row><entry>p9000</entry>	<entry>lts_xp9000-2.0-1.i386.rpm</entry>	<entry>lts-xserver-p9000_2.0-1_all.deb</entry></row>
<row><entry>s3</entry>		<entry>lts_xs3-2.0-1.i386.rpm</entry>		<entry>lts-xserver-s3_2.0-1_all.deb</entry></row>
<row><entry>s3v</entry>		<entry>lts_xs3v-2.0-1.i386.rpm</entry>		<entry>lts-xserver-s3v_2.0-1_all.deb</entry></row>
<row><entry>svga</entry>	<entry>lts_xsvga-2.0-1.i386.rpm</entry>		<entry>lts-xserver-svga_2.0-1_all.deb</entry></row>
<row><entry>vga16</entry>	<entry>lts_xvga16-2.0-1.i386.rpm</entry>	<entry>lts-xserver-vga16_2.0-1_all.deb</entry></row>
<row><entry>w32</entry>		<entry>lts_xw32-2.0-1.i386.rpm</entry>		<entry>lts-xserver-w32_2.0-1_all.deb</entry></row>
</tbody>
</tgroup>
</table>

Welche X-Server benötigt werden, hängt von den Grafikkarten der Terminals ab.
Meistens wird der X-Server für SVGA-kompatible Grafikkarten funktionieren.
Falls unklar ist, welcher X-Server nötig ist, finden sich in der
Hardwaredatenbank von SuSE 
(<ulink url="http://cdb.suse.de/">http://cdb.suse.de/</ulink>) und 
auf den Seiten des XFree86-Projektes 
(<ulink url="http://www.xfree86.org/">http://www.xfree86.org/</ulink>) weitere
Informationen.

<para>
<table>
<title>Kernelpakete</title>
<tgroup cols="3">
<thead>
<row><entry>Netzwerkkarte</entry>	<entry>rpm-Paket</entry>				<entry>deb-Paket</entry></row>
</thead>
<tbody>
<row><entry>3c509</entry>		<entry>lts_kernel_3c509-2.2-0.i386.rpm</entry>		<entry>lts-kernel-3c509_2.2-1_all.deb</entry></row>
<row><entry>3c905</entry>		<entry>lts_kernel_3c905-2.2-0.i386.rpm</entry>		<entry>lts-kernel-3c905_2.2-1_all.deb</entry></row>
<row><entry>all</entry>			<entry>lts_kernel_all-2.2-0.i386.rpm</entry>		<entry>lts-kernel-all_2.2-1_all.deb</entry></row>
<row><entry>eepro100</entry>		<entry>lts_kernel_eepro100-2.2-0.i386.rpm</entry>	<entry>lts-kernel-eepro100_2.2-1_all.deb</entry></row>
<row><entry>ne2000</entry>		<entry>lts_kernel_ne2000-2.2-0.i386.rpm</entry>		<entry>lts-kernel-ne2000_2.2-1_all.deb</entry></row>
<row><entry>rtl8139</entry>		<entry>lts_kernel_rtl8139-2.2-0.i386.rpm</entry>	<entry>lts-kernel-rtl8139_2.2-1_all.deb</entry></row>
<row><entry>tulip</entry>		<entry>lts_kernel_tulip-2.2-0.i386.rpm</entry>		<entry>lts-kernel-tulip_2.2-1_all.deb</entry></row>
</tbody>
</tgroup>
</table>

Die verfügbaren Kernel decken nicht alle Netzwerkkarten ab. Der Kernel <literal>all</literal>
enthält alle Netzwerkkartentreiber. Wenn für die gewünschte Karte
kein Kernel vorhanden ist, und der <literal>all</literal>-Kernel nicht funktioniert, muss ein
Kernel selber erstellt und nach <filename>/tftpboot/lts/</filename> kopiert werden.
</para>

<sect3>
<title>Kernel für ein Terminal selber bauen</title>
<para>
Wir gehen hier davon aus, dass Sie wissen, wie man einen Kernel compiliert (z. B.
aus einem der vielen Linuxbücher) und beschreiben nur die Besonderheiten für den
plattenlosen Betrieb. Bei der Kernelkonfiguration muss der Treiber der Netzwerkkarte
fest in den Kernel eincompiliert werden (kein Modul!). Dies liegt daran, daß das
Wurzeldateisystem (welches die Module enthält) über das Netzwerk geholt wird, und dazu
muss natürlich die Netzwerkkarte funktionieren. Andere zu aktivierende Optionen (auch
diese dürfen keine Module sein) stehen in <xref linkend="kernel-optionen">
fixme: dieser Tabelle
.


<table id="kernel-optionen">
<title>Benötigte Kernel-Optionen</title>
<tgroup cols="1">
<tbody>
<row><entry>Block devices->RAM disk support</entry></row>
<row><entry>Networking options->IP kernel-level configuration support</entry></row>
<row><entry>Networking options->DHCP support</entry></row>
<row><entry>Filesystems->Network File Systems->NFS filesystem support</entry></row>
<row><entry>Filesystems->Network File Systems->Root filesystem on NFS</entry></row>
</tbody>
</tgroup>
</table>
</para>

<para>
Manche der Optionen sind erst anwählbar, wenn andere aktiviert sind. Daher empfielt
es sich, in der Reihenfolge der Tabelle vorzugehen.
Prinzipiell ist es möglich, Kernel der Version 2.0.x, 2.2.x oder 2.4.x zu verwenden.
Die älteren Kernel können für ältere Hardware noch ganz nützlich sein. Einmal
verbrauchen sie etwas weniger Speicher, und zum Anderen will manche betagte Hardware
mit den neueren Versionen nicht richtig laufen.
Beispielkonfigurationsdateien, in denen außer der Netzwerkkarte schon alle nötigen
Einstellungen vorgenommen sind, finden Sie je nach verwendeter Distribution unter
<filename>/usr/share/doc/termserv-doc/</filename> oder <filename>/usr/share/doc/packages/termserv-doc/</filename>, 
wenn Sie das Paket <literal>termserv-doc</literal> installiert haben.

TODO: Dateien erstellen.

</para>

<para>
Nachdem der Kernel erfolgreich compiliert wurde, muss er noch mit mknbi-linux in ein
von Etherboot lesbares Format gewandelt werden. Wie das geht, steht in der
Etherboot-Dokumentation. Anschließend muss der nun im <quote>tagged image format</quote> vorliegende
Kernel nach <filename>/tftpboot/lts/</filename> kopiert werden.
</para>
</sect1>

<sect1>
<title>Installation von CD</title>

<sect2>
<title>Debian/GNU Linux und Abkömmlinge</title>

<para>
Bei Debian-Systemen müssen Sie die Terminalserver-CD dem Paketmanagementsystem mit

<programlisting>
apt-cdrom add
</programlisting>

bekannt machen. Die CD muss sich hierzu im Laufwerk befinden. Anschließend können
Sie den Terminalserver mit

<programlisting>
apt-get install task-termserv
</programlisting>

installieren. Weitere Eingriffe sind nicht nötig.
</para>

<sect2>
<title>Rpm-basierte GNU/Linux-Distributionen</title>

<comment>
% RPM: Welche Pakete müssen eingespielt werden
% RPM hat ja leider kein apt "autoresolve dependencies"
</comment>
</sect1>

<sect1>
<title>Installation über das Internet</title>

<para>
Die Installation über das Internet ist nur mit Debian GNU/Linux-Systemen
und Abkömmlingen möglich. Selbstverständlich geht das nur, wenn Ihr 
zukünftiger Terminalserver eine Verbindung zum Internet hat.
</para>

<para>
Tragen Sie

<programlisting>
deb http://termserv.berlios.de/debian stable main
</programlisting>

in die Datei <filename>/etc/apt/sources.list</filename> ein. Das Paketmanagementsystem
muss nun diese zusätzliche Quelle für Pakete auswerten. Rufen Sie dazu

<programlisting>
apt-get update
</programlisting>

auf. Den Terminalserver können Sie jetzt mit

<programlisting>
apt-get install task-termserv
</programlisting>

installieren.
</para>
</sect1>

<sect1>
<title>Konfiguration</title>

<para>
Bei der Installation der Terminalserver-Pakete wurde auch die
Administrationssoftware Webmin mitinstalliert. Die Konfiguration des
Terminalservers wird im Folgenden auf Basis dieses Werkzeugs erklärt.
Fortgeschrittenen Adminstratoren werden die analogen manuellen Kommandos und Veränderungen
an Konfigurationsdateien einsichtig sein.
</para>

<para>
Die Webmin-Software ist am Terminalserver selbst sowie über jeden ans das
Netzwerk angeschlossenen Rechner aufrufbar. Wenn Sie innerhalb des Netzwerkes
dann den Terminalserver mit Ihrem Browser auf dem Webmin-Port (10000)
aufrufen, z.B. <literal>http://192.168.0.254:10000/</literal>, erscheint folgender
Anmeldebildschirm:
</para>

<screenshot>
<screeninfo>Anmeldebildschirm von Webmin</screeninfo>
<mediaobject>
<imageobject><imagedata fileref="userguide-installconfig-config-webmin-loginscreen.eps" format="eps"></imageobject>
<imageobject><imagedata fileref="userguide-installconfig-config-webmin-loginscreen.png" format="png"></imageobject>
<textobject><phrase>Anmeldebildschirm von Webmin</phrase></textobject>
<caption><para>Anmeldebildschirm von Webmin</para></caption>
</mediaobject>
</screenshot>

<para>
Anmelden können Sie sich als root-Benutzer mit Ihrem root-Passwort.
</para>
 
<sect2>
<title>Anpassungen an ein vorhandenes Netzwerk</title>

<para>
Die Terminalserver-Pakete konfigurieren das System teilweise mit
Standardwerten. Diese Standardwerte müssen Sie natürlich für ein bestehendes
Netzwerk anpassen.

In addition to the common configuration we describe a special case:
the use of the terminalserver together with the
c´t/ODS communications server Arktur.
This is a special Linux distribution that is easy to set up and targeted at
teachers who know nothing about linux. More info (in German) is available at
<ulink url="http://www.heise.de/ct/schan/">http://www.heise.de/ct/schan/</ulink>.
We describe this case here because Arktur is widely used at german schools.
</para>
 
<sect2>
<title>Einrichtung des DHCP-Servers</title>

<para>
Der DHCP-Dienst kann entweder auf dem Terminalserver oder auf einem anderen
Rechner laufen. Einzige Bedingung ist, dass der andere Rechner von den Terminals
über das Netzwerk erreicht werden kann.
</para>

<para>
Befinden sich mehr als ein DHCP-Server im Netz, so ist unbedingt darauf zu
achten, dass sich die IP-Adressbereiche, die jeder bedient, nicht überschneiden.
Anderenfalls hängt es vom Zufall ab, von welchem DHCP-Server eine Anfrage
nach einer IP-Adresse zuerst beantwortet wird.
</para>

<sect3>
<title>DHCP auf dem Terminalserver</title>

<para>
über Webmin
</para>
 
<sect3>
<title>Using Arktur as DHCP server</title>

<para>
On the c´t/ODS communications server Arktur is a DHCP-server running already.
If there are other hosts beside the terminals on the network,
it is desirable to use this DHCP server also for the terminals. In order to do this
the following changes have to be applied to the file <filename>/etc/dhcpd.conf</filename>
on Arktur:

<orderedlist>
<listitem>
<para>A group
<programlisting>
group {
    next-server termserv;
    use-host-decl-on;
}
</programlisting>
has to be added. <literal>termserv</literal> is the name of the terminalserver.
<literal>next-server termserv;</literal> tells all terminals in this group the name of the next
server. This is the server that provides the linux kernel.

With <literal>use-host-decl-on;</literal> the terminals are getting their names in addition to 
their ip-addresses. If this entry is missing, they are not able to find their
section in <filename>/tftpboot/lts/ltsroot/etc/lts.conf</filename>.
If more than one terminalserver is used, each gets its own group.

<listitem>
<para>Each terminal muts have an entry of the form
<programlisting>
    host Client-A40 {
        hardware ethernet 08:00:07:26:c0:a5;
        filename "/tftpboot/lts/vmlinuz.ne2000";
        fixed-address Client-A40;
    }
</programlisting>
within this group.

<literal>Client-A40</literal> is the name of the terminal. The nameserver must know this name
and resolve it to an IP-address. A table of the already known address ranges
of Arktur is at
<xref linkend="dns-arktur">
fixme: DNS on Arktur
.

<literal>08:00:07:26:c0:a5</literal> is the MAC address of the network interface card (NIC).

<filename>/tftpboot/lts/vmlinuz.ne2000</filename> is the name of the kernel that should boot
on the terminal.
It must reside on the host mentioned above (here <literal>termserv</literal>), and of course it
must contain a driver for the NIC of the terminal.
Some Linux distributions require to remove the leading <filename>/tftpboot</filename>.
In case of doubt just try both possibilities.

<listitem>
<para>If the IP address ranges listed at <xref linkend="dns-arktur">
fixme: DNS on Arktur
are not enough, you have to define a new subnet (analogous to the existing
subnet entries), for example
<programlisting>
subnet 192.168.5.0 netmask 255.255.255.0 {
    option routers 192.168.5.1;
}
</programlisting>
In addition you have to adjust the nameserver to assign names to the new addresses.
</orderedlist>

<para>
The configuration method that is described here is only one
under many possibilities. If you want ot know more, please read the manual page
of <filename>dhcpd.conf</filename> (with the command <command>man dhcpd.conf</command>).
</para>

<para>
You can still use the description above as a starting point
if you don't use Arktur, but another DHCP-server.
</para>

<para>
<sect2>
<title>Einrichtung des DNS-Servers</title>

<sect3>
<title>DNS auf dem Terminalserver</title>

<para>
über Webmin
</para>
 
<sect3>
<title>DNS on Arktur</title>

<para>
An der Konfiguration des standardmäßig auf Arktur laufenden Nameservers sind
normalerweise keine Änderungen nötig. Die verfügbaren Namen und IP-Adressen
stehen unter <xref linkend="dns-arktur">
fixme: der angegebenen Tabelle
.

<table id="dns-arktur">
<title>Voreingerichtete Namen und IP-Adressen auf Arktur</title>
<tgroup cols="2">
<colspec colname="col1">
<colspec colname="col2">
<spanspec namest="col1" nameend="col2" spanname="col1-2">
<thead>
<row><entry>Name</entry>			<entry>IP Address</entry></row>
</thead>
<tbody>
<row><entry><literal>Client-A40</literal></entry>		<entry><literal>192.168.0.40</literal></entry></row>
<row><entry spanname="col1-2" align="center">&vellip</entry></row>
<row><entry><literal>Client-A250</literal></entry>	<entry><literal>192.168.0.250</literal></entry></row>
<row><entry><literal>Client-B10</literal></entry>		<entry><literal>192.168.1.10</literal></entry></row>
<row><entry spanname="col1-2" align="center">&vellip</entry></row>
<row><entry><literal>Client-B250</literal></entry>	<entry><literal>192.168.1.250</literal></entry></row>
<row><entry><literal>Client-C10</literal></entry>		<entry><literal>192.168.2.10</literal></entry></row>
<row><entry spanname="col1-2" align="center">&vellip</entry></row>
<row><entry><literal>Client-C250</literal></entry>	<entry><literal>192.168.2.250</literal></entry></row>
<row><entry><literal>Client-D10</literal></entry>		<entry><literal>192.168.3.10</literal></entry></row>
<row><entry spanname="col1-2" align="center">&vellip</entry></row>
<row><entry><literal>Client-D250</literal></entry>	<entry><literal>192.168.3.250</literal></entry></row>
</tbody>
</tgroup>
</table>
</para>

<sect2>
<title>The LTSP Module - setup of the terminal hardware</title>
<comment>TODO!</comment>
</sect2>
</chapter>

<chapter>
<title>Installation of the terminals</title>

<para>
Before we will come to the installation of the terminals,
we need a few basics about the starting procedure of PC's.
</para>

<para>
Directly after power on the BIOS (Basic Input and Output System) starts.
After some tests it executes the bootloader of the operating system.
The location where the bootloader is fetched from can be controlled
via the BIOS setup. Normally there are the options floppy, harddisk,
CDROM and network (newer PC's only).
</para>

<para>
Normally the bootloader loads the operating system. Some bootloaders offer
to choose between different operating systems. In our case the bootloader
is called either etherboot or netboot. Both do the same thing:
Instead of loading the operating system from disk it is fetched
from a server over the network.
</para>

<para>
In the following chapters we assume that you use etherboot, because it
is more flexible than netboot and it is developped more actively.
A difference between netboot and etherboot is that etherboot needs
a driver for every NIC while netboot provides a sort of mini-DOS.
Therefore netboot can be used with all NICs that have a DOS-packet driver.
Normally one should use etherboot, but if etherboot does not support
the desired NIC, one could try netboot.
</para>

<para>
The location where etherboot ist loaded from does not matter at all for
the further booting process of the terminals. The only reason to prefer
one are practical ones. We discuss four methods for starting etherboot in
the next chapters:
From a bootfloppy, from the bootsector of the harddisk, from DOS and
from a booteprom.
</para>

<para>
Furthermore we assume that you have internet access and that you can load the
etherboot-images from <ulink url="http://rom-o-matic.net/">http://rom-o-matic.net/</ulink>.

<sect1>
<title>Creating an etherbootimage with the ROM-o-matic</title>

<para>
Marty Connor provides a service on
<ulink url="http://rom-o-matic.net/">http://rom-o-matic.net/</ulink>
where you can create custom configured etherbootimages on demand and
download them.
Using this site is simple:
</para>

<para>
You can choose the desired version of etherboot on the starting page.
Normally you should choose the newest <quote>Production Release</quote>.
The next page is a form containing four topics. The first one chooses
the NIC driver. If you don't know the suitable driver for your NIC,
you may find it out on the etherboot homepage at
<ulink url="http://etherboot.sourceforge.net/">http://etherboot.sourceforge.net/</ulink>
or with the help of the NIC database at
<ulink url="http://etherboot.sourceforge.net/db/">http://etherboot.sourceforge.net/db/</ulink>.
With the second topic you can adjust several options. Normally you don't need
to do that.
The third button chooses the desired imageformat, and the fourth generates the
image. The format of the image depends on the booting method and is described
in the relevant chapters.
</para>
</sect1>

<sect1>
<title>Terminals with bootfloppy</title>

<para>
The simplest method to start a terminal is a bootfloppy, because it can be
created quickly on another host and you only need to insert it into the
floppy drive in order to use it. Therefore this method is well suited for
testing purposes. A disadvantage are the movable parts and the dust
sensitiveness of the floppy drive. Another disadvantage is that the
bootfloppy can get lost. You can circumvent this one if you mount
the drive with the inserted disk inside the cover, but you cannot use
it normally any more if you do this.
</para>

<para>
The image format for the ROM-o-matic is <quote>Floppy Bootable ROM Image (.lzdsk)</quote>.
Under Linux you can write the received file (e.g. eb-5.0.2-ne.lzdsk) with
the command

<programlisting>
cat eb-5.0.2-ne.lzdsk &gt; /dev/fd0
</programlisting>

onto the floppy in the first drive.
</para>

<caution>
<para>
This overwrites the contents of the floppy, and if you mistype
<filename>/dev/fd0</filename> Bad Things can happen
(Overwriting of the harddisk etc).
</para>
</caution>

<para>
Of course you need writing rights for the floppy drive. If you are
root it should work in all cases.
</para>

<para>
Under DOS or windows you can use the program rawrite.exe to create the
bootdisk. You can find it on one of the installation CD's of almost
every Linux Distribution or at
<ulink url="http://uranus.it.swin.edu.au/~jn/linux/">http://uranus.it.swin.edu.au/~jn/linux/</ulink>.
</para>

<para>
Because the floppy image is very small, it is normal when the floppy drive's
LED lights only shortly and you almost hear no noises from the drive.
</para>

<para>
That was it! Now you can start the terminal with this floppy.
</para>
</sect1>

<sect1>
<title>Terminals with booteprom</title>

<para>
Booting a terminal with a booteprom is the most elegant way. This method
is also used by commercially available solutions. The main advantage is
that you don't need any moving parts. The disadvantage is that programmed
booteproms and NICs with programmed booteproms are rather expensive and
that you need an eprom burner and an erasing lamp if you want to program
eproms yourself. The only exception are flasheproms, these can be programmed
"in circuit" without additional hardware.
</para>

<para>
The image format for the ROM-o-matic is <quote>Binary ROM Image (.lzrom)</quote>.
</para>

<para>
If you are the lucky owner of a NIC with a flasheprom, then you
can use the accompanying flashprogram to load the flasheprom with the image.
</para>

<para>
You have to program the received file into the eprom with an
eprom burner if you have a NIC with a socket for a normal eprom.
Alternatively several vendors offer programmed eproms.
You cand find a list at
<ulink url="http://etherboot.sourceforge.net/commercial.html">http://etherboot.sourceforge.net/commercial.html</ulink>.
Finally the eprom has to be inserted into the socket on the NIC. Note that
the notches on the small sides of the eprom and the socket have to match.
</para>

<para>
Most etherboot images are 16 kB in size. Suitable eprom chips are named
27c128. However, the 32 kB chips 27c258 are pin compatible to the 27c128
and sold more often, so they are cheaper. Therefore these chips are
preferrable.
Some NIC's require the 16 kB type. You can nevertheless use the 27c256
with these cards if you don't burn directly the image but a 32 kB image
(here <filename>eb-5.0.2-ne-big.lzrom</filename>), that you can create
for example with
<programlisting>
cat eb-5.0.2-ne.lzrom eb-5.0.2-ne.lzrom > eb-5.0.2-ne-big.lzrom
</programlisting>
under GNU/Linux or
<programlisting>
copy eb-5.0.2-ne.lzrom eb-5.0.2-ne.lzrom eb-5.0.2-ne-big.lzrom
</programlisting>
under DOS or Windows.
</para>

<para>
In most cases the eprom/flasheprom has to be activated with a
configuration tool before it can be used.
</para>

<para>
This chapter only treats the most important topics and is rather an
overview over the capabilities of booteproms. See the etherboot
documentation for more advanced topics such as integrating etherboot
into the BIOS of newer PC's or using an existing PXE compatible
booteprom.
</para>
</sect1>

<sect1>
<title>Terminals with harddisk</title>

<para>
You may ask wether a terminal with a harddisk makes sense at all since
nothing is stored locally.
The answer is: Yes, if it has little memory, you can then use the harddisk as
swap space.
In most other cases you should probably remove the harddisks, because
they are noisy, consume electrical power and are dying at some day because
of the mechanical moving parts.
</para>

<para>
The image format for the ROM-o-matic is the same as the one used by
bootfloppies. The only difference lays in putting the image onto the
disk.
</para>

<para>
There are two possibilities: Transfer the image with a floppy or mount
the harddisk into another PC.
</para>

<para>
If the terminal has a floppy drive you can copy the image onto a
formatted floppy. The command under Linux is
<programlisting>
cp eb-5.0.2-ne.lzdsk /floppy/
</programlisting>
assuming the floppy is mounted under <filename>/floppy/</filename>.
Of course you can also copy the image under DOS or Windows.
</para>

<para>
Now you can start the terminal with a Pocket Linux or the
rescue disk of a normal Linux distribution.
After logging in as root or gaining root privileges by another way
insert the floppy created above and mount it:

<programlisting>
mount /dev/fd0 /mnt
</programlisting>

Of course the directory <filename>/mnt/</filename> must exist. If it does
not exist, create it with the command

<programlisting>
mkdir /mnt
</programlisting>

Now copy the etherboot image to the harddisk:

<programlisting>
cat /mnt/eb-5.0.2-ne.lzdsk > /dev/hda
</programlisting>

In case you have a SCSI system replace <filename>/dev/hda</filename>
with <filename>/dev/sda</filename>.
</para>

<para>
If the terminal does not have a floppy drive you have a bit more work.
Remove the harddisk of the terminal and mount it into a Linx PC.
If the disk is connected as master on the second IDE channel for example,
you can transfer the image with

<programlisting>
cat /mnt/eb-5.0.2-ne.lzdsk > /dev/hdc
</programlisting>
</para>

<caution>
<para>
A typo at <filename>/dev/hdc</filename> can lead to very unpleasant results!
</para>
</caution>

<para>
Now the disk can be put back into the terminal.
</para>
</sect1>

<sect1>
<title>Terminals with DOS</title>

<para>
If the terminal runs DOS as second operating system, it can load
etherboot also from DOS. You can choose between operating the pc under
DOS or as terminal with the bootmenu of MS-DOS 6.x or a selfwritten
batchfile upon startup.
</para>

<para>
We assume that DOS is already installed on harddisk. The image format for the
ROM-o-matic is <quote>DOS.COM Executable ROM Image</quote>.
Aftre copying the received file on disk it can be executed and then
etherboot starts. That's it!
</para>
</chapter>

<chapter>
<title>Systemadministration</title>

<para>
mittels webmin
</para>

<sect1>
<title>User and Group Management</title>

<sect2>
<title>Direkt auf dem Terminalserver</title>
<comment>TODO!</comment>
</sect2>

<sect2>
<title>Übernahme der Benutzer von einem anderen Server</title>

<para>
Möglich von jedem NIS/NFS-Server.
Evtl. Sonderweg für Arktur.
</para>
</sect1>

<sect1>
<title>Zugriffsrechteverwaltung</title>
<comment>TODO!</comment>
</sect1>

<sect1>
<title>Speicherplatzbegrenzung mit Quotas</title>

<para>
Peter: nötig? Selbst der Arktur bietet das nur als Option, die von Hand eingestellt werden muss. Außerdem müsste dann auf dem TS ein ext2 laufen, das Ganze ist nicht ganz einfach einzustellen.
</para>

<para>
Christian: ja, wir brauchen das. Wenn jemand bei der Serverinstallation
falsch partitioniert, kann man die Kiste mit Hilfe eines vollen Home-Verzeichnisses
vollständig lahmlegen.
</para>
</sect1>
</chapter>

<chapter>
<title>Fehlersuche</title>
<comment>TODO!</comment>
</chapter>
<chapter>
<title>Miszellaneen</title>
<sect1>
<title>Impressum</title>
<comment>TODO!</comment>
</sect1>
<sect1>
<title>Lizenz</title>
<para>
GFDL.
</para>
</sect1>
</chapter>
</book>

